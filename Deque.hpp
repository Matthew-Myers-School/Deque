#include <assert.h>#include <string.h>#include <dlfcn.h>#include <assert.h>#include <stdint.h>#include <random>#include <unistd.h>#define Deque_DEFINE(t)      \struct Deque_##t;\struct Deque_##t##_Iterator\{\    t * _ptr;\    void inc(struct Deque_##t##_Iterator * it)\    { it->_ptr++; }\    void dec(struct Deque_##t##_Iterator * it)\    { it->_ptr--; }\    t & deref(struct Deque_##t##_Iterator * it) \    { \        \        return *(it->_ptr); \    } \}; \\bool Deque_##t##_Iterator_equal(struct Deque_##t##_Iterator at, struct Deque_##t##_Iterator end) \{ \    if ( at._ptr == end._ptr)\        return true;\    else\        return false;\}\const struct Deque_##t##_Iterator it(t * ptr) \{  \    Deque_##t##_Iterator i;\    i._ptr = ptr;\    return i;\};  \ \ \ \ \\ \struct Deque_##t\{\  \    int sizeData = 0;\    int maxSize = 10;\    t type;\    t * data = new t [10];\    char type_name[10] = "Deque_int";\    t &(*at)(Deque_##t *, int i);\    void (*delet)(Deque_##t *);\    bool (*lessthan)(const t &, const t &);\ \    void clear(Deque_##t * z)\    {\        z->data = 0;\        z->sizeData = 0;\    }\    void dtor(Deque_##t * z)\    {\        free(z->data);\    \    }\    struct  Deque_##t##_Iterator end(struct Deque_##t * q) \    { \        return it(&q->data[ q->sizeData-1]);\    }; \    struct  Deque_##t##_Iterator begin(struct Deque_##t * q) \    { \        return it(&q->data[0]);\    }; \    t & front(struct Deque_##t * q)\    { \        return  q->data[0];\    } \    t & back(struct Deque_##t * q)\    {\        return (q->data[ q->sizeData -1]);\    };\         \    bool empty(struct Deque_##t * q)\    {\        if ( q->sizeData == 0)\            return true;\        return false;\    };\    int size(struct Deque_##t * q)\    {\        return  q->sizeData;\    }\    void push_back(struct Deque_##t * q, t num)\    {\        if ( q->sizeData+1 < q->maxSize)\        {\            q->data[q->sizeData] = num;\             q->sizeData++;\        }\        else\        {\            t * newDat;\            newDat = (t*) malloc(sizeof(q->data)*2);\    for (int i = 0; i < q->sizeData; i++)\    {\        newDat[i] = q->data[i];\    }\    newDat[q->sizeData] = num;\    q->data = newDat;\    free (newDat);\    q->sizeData++;\        }\    };\    void push_front(struct Deque_##t * q, t num)\    {\        if ( q->sizeData+1 < q->maxSize && q->sizeData != 0)\        {\            t replace = q->data[0];\            q->data[0] = num;\            t saveDat;\            for (int i = 0; i < q->sizeData; i++)\            {\                saveDat = q->data[i+1];\                q->data[i+1] = replace;\                replace = saveDat;\            }\            q->sizeData++;\\        }\        else if (q->sizeData == 0)\        {\            q->data[0] = num;\        }\        else\        {\            t * newDat;\            newDat = (t*) malloc(sizeof(q->data)*2);\            for (int i = 0; i < q->sizeData; i++)\            {\                newDat[i+1] = q->data[i];\            }\            newDat[0] = num;\            q->data = newDat;\            free (newDat);\            q->sizeData++;\        }\};\    void pop_back(struct Deque_##t * q)\    {\        if ( q->sizeData > 0)\             q->sizeData--;\    }\    void pop_front(struct Deque_##t * q)\    {\        if ( q->sizeData > 0)\        {\            for (int i = 0; i <  q->sizeData; i++)\            {\                \                q->data[i] = q->data[i+1];\            }\             q->sizeData--;\        }\    }\};\t &Deque_##t##_at(Deque_##t *ap, int i){\    assert(i < ap->sizeData);\    return ap->data[i];  \}\void Deque_##t##_delete(Deque_##t *ap) {\    free(ap);\}\bool Deque_##t##_equal(Deque_##t x,  Deque_##t y)\{\\    if (x.sizeData == y.sizeData)\    {\        for (int i = 0; i < x.sizeData; i++)\        {\            if ( x.lessthan(x.data[i] , y.data[i]))\                return false;\            else if ( y.lessthan(y.data[i],x.data[i]))\                return false;\        }\        return true;\    }\    else\        return false;\}\Deque_##t *Deque_##t##_new()\{\    Deque_##t *ap = (Deque_##t *) malloc(sizeof(Deque_##t));\    ap->at = &Deque_##t##_at;\    ap->delet = &Deque_##t##_delete;\    return ap;\}\void Deque_##t##_ctor(Deque_##t *ap, bool (newfunc)(const t & dat1, const t & dat2))\{\    ap->lessthan = newfunc;\}\t at(Deque_##t * q, int i)\{\    return q->data[i];\};